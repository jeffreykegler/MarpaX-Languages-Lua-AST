# highlights
	extensible parser
		malleable syntax, smart preprocessing
		optional round-trip (AST includes comments) parsing
	traversable Lua AST
	BNF-based metalua reimplementation -- principles.md
		Abstract Syntax Tree grammar -- http://metalua.luaforge.net/metalua-manual.html

# Lua BNF -- BNF as a first-class object
	design note -- https://github.com/jeffreykegler/kollos/blob/master/design/notes.md#grammars
	discussion -- https://github.com/jeffreykegler/kollos/commit/f82664ccda234bb00a79fd776ba6f679b4e5d333

	detect the first bare <BNF rules> then 
		set the flag to die() if another <BNF rules>, bare or wrapped, is detected
	if a wrapped <BNF rules> is detected first, 
		set the flag to die() if another bare <BNF rules> is detected
	
	g = grammar ()
		...
	end
	-- [[ grammar metatable is set to have parse(input) method 
		    to parse input, evaluate the parse and return value
	]]
	
	# grammars can be called as function to parse input, evaluate the parse and return value
	value = g(input)
	value = g(input, options)
	
	# syntactic sugar -- parse operator
	string <op parse> grammar, options
	# returns true if string is in a language generated by the grammar, false otherwise
	string ~~ grammar, options
	# reverse of the above
	string !~ grammar, options 
	# set string to the value returned by grammar.parse(input, options)
	string =~ grammar, options 
	
	# set metatables of strings to have translate(g) metamethod 
	which 
		parses it with grammar g,
		evaluates the parse and 
		sets the string to the returned value
	
	let us define ::= as a lua binop with appropriate metatable
	lhs ::= rhs1 rhs2 rhs3 ... action block end
	consider 
	semantics rewrite lhs as rhs
	a ::= b, c ::= d
	
# BNF-driven programming -- translation
	metalua ast format
		http://metalua.luaforge.net/metalua-manual.html
	ternary choice operator
	lisp macros 
		http://cl-cookbook.sourceforge.net/macros.html
		http://stackoverflow.com/questions/267862/what-makes-lisp-macros-so-special
	
	http://nova-fusion.com/2011/06/30/lua-metatables-tutorial/
	
	polymorphism by generating code based on input
	define a function as a string
	parse and evaluate it to another function
	
# regex features needed in SLIF/LUIF
	balanced delimiter rules by adverbs
		right => '[[' 
		left => ']]' 
		escape => '\\'
		<in parens> ~ <text> left => '(' right => ')' escape => "\\" #"
		
		<text in possibly nested balanced delimiters> ~ 
			<symbol name for text between delimiters>
			'right'  => <right delimiter>
			'left' 	 => <left delimiter>
			'escape' => <escape character>
			
	look-ahead assertions -- to match balanced delimiters
		(?<=text)
		(?=>text)
	character class quantifiers
		[]{n,m}
	
# put lua test suite running and formatting under xt/author

# extensible (capture group-based) lexer
		sub read ( $recce, $input ){} for it with external lexing
		terminals, literals, L0 rules, unicorns, read
		custom lexemes, e.g. 
			String ::= <long nestable string> 
			<long nestable string> ~ ...
			exist in SLIF grammar, but do not really parse nested strings
			<long nestable string> => regex will ensure that it does

# the Lua SLIF grammar is highly ambiguous, at times with over 100 ASTs
	we use the first value() now
	need to handle precedence

# ast distill
	convert all left recursions, e.g. statements/stat, to arrays

# move fmt to handlers ?
	returning to traversal, like Marpa::R2:ASF
	handlers => {
		'stat/if' => sub {
		},
	}

# build ASTs as documented in metalua

# parser cases for extensible lua parser 
	# luadoc - use lua comments to build docs, like godoc or javadoc
		
	# help port lua 5.1 code to lua 5.2 -- What Lua 5.1 code breaks in Lua 5.2
	http://www.luafaq.org/#T8.1
	# smart preprocessing
	  malleable syntax -- like the language but hate some of its syntax
		Hate ends? Use curlies!
			for ... end 				-> for ... { ... }
			do ... end 					-> do { ... }
			while ... end 			-> while { ... }
			repeat ... until 		-> repeat { ... } until
			function () ... end	-> sub (...){...}
		replace some grammar BNF rules with new ones

		# blocks
		# comments
		# strings
		# local to my

	# motivation for formatter
		http://blog.golang.org/go-fmt-your-code

# More parser tests:
http://lua-users.org/wiki/LuaGrammar

# Lua Links
# ---------

# lua formatters/ast emitters
http://metalua.luaforge.net/
http://lua-users.org/wiki/LuaInspect
https://github.com/batrick/lunadry # most recent
http://codepad.org/vRQx1O8A # block/non-block keywords
http://lua-users.org/wiki/SourceCodeFormatter
https://github.com/LuaDist/luapretty/blob/master/src/lua-formatter.lua
http://notebook.kulchenko.com/programming/lua-beautifier-in-55-lines-of-perl

# style guides
http://lua-users.org/wiki/LuaStyleGuide
http://sputnik.freewisdom.org/en/Coding_Standard

# testing framework
http://olivinelabs.com/busted/
# code optimizer
http://lua-users.org/wiki/SourceOptimizer

# Lua IDE
http://studio.zerobrane.com/

# AST-based formatter/linter
	subtle comma (Kolesnikov)

# Questions to be asked when enough tests will pass
# -------------------------------------------------

#
# How to/If we need to interpret these escape sequences (2.1 – Lexical Conventions) 
#
    <double quoted String char> ~ <C escape sequence>
    <double quoted String char> ~ <escape sequence of decimal digits>

    <single quoted String char> ~ <C escape sequence>
    <single quoted String char> ~ <escape sequence of decimal digits>

    <C escape sequence> ~ '\a' # bell
    <C escape sequence> ~ '\b' # backspace
    <C escape sequence> ~ '\f' # form feed
    <C escape sequence> ~ '\n' # newline
    <C escape sequence> ~ '\r' # carriage return
    <C escape sequence> ~ '\t' # horizontal tab
    <C escape sequence> ~ '\v' # vertical tab
    <C escape sequence> ~ '\\' # backslash
		\"	double quote #"
		\'	single quote #'
		\[	left square bracket
		\]	right square bracket
   
    
Links
-----

https://github.com/jddurand/MarpaX-Languages-C-AST/blob/master/lib/MarpaX/Languages/C/AST/Grammar/ISO_ANSI_C_2011.pm
https://github.com/jeffreykegler/Marpa--R2/blob/master/cpan/lib/Marpa/R2/meta/metag.bnf
