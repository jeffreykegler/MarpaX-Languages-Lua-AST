# highlights
	extensible parser
		malleable syntax, smart preprocessing
		optional round-trip (AST includes comments) parsing
	traversable Lua AST

# BNF statements grouping
	-- https://github.com/jeffreykegler/kollos/commit/f82664ccda234bb00a79fd776ba6f679b4e5d333
	default grammar must be a single group of BNF statements <BNF rules>
	
	can Ruby Slippers be used to wrap default grammar in default_g = <grammar> <BNF rules> end?
	
	if it cannot, detect the first bare <BNF rules> then 
		set the flag to die() if another <BNF rules>, bare or wrapped, is detected
	if a wrapped <BNF rules> is detected first, 
		set the flag to die() if another bare <BNF rules> is detected

# put lua test suite running and formatting under xt/author

# extensible (capture group-based) lexer
		sub read ( $recce, $input ){} for it with external lexing
		terminals, literals, L0 rules, unicorns, read
		custom lexemes, e.g. 
			String ::= <long nestable string> 
			<long nestable string> ~ ...
			exist in SLIF grammar, but do not really parse nested strings
			<long nestable string> => regex will ensure that it does

# the Lua SLIF grammar is highly ambiguous, at times with over 100 ASTs
	we use the first value() now
	need to handle precedence

# ast distill
	convert all left recursions, e.g. statements/stat, to arrays

# move fmt to handlers ?
	returning to traversal, like Marpa::R2:ASF
	handlers => {
		'stat/if' => sub {
		},
	}

# build ASTs as documented in metalua

# parser cases for extensible lua parser 
	# luadoc - use lua comments to build docs, like godoc or javadoc
		
	# help port lua 5.1 code to lua 5.2 -- What Lua 5.1 code breaks in Lua 5.2
	http://www.luafaq.org/#T8.1
	# smart preprocessing
	  malleable syntax -- like the language but hate some of its syntax
		Hate ends? Use curlies!
			for ... end 				-> for ... { ... }
			do ... end 					-> do { ... }
			while ... end 			-> while { ... }
			repeat ... until 		-> repeat { ... } until
			function () ... end	-> sub (...){...}
		replace some grammar BNF rules with new ones

		# blocks
		# comments
		# strings
		# local to my

	# motivation for formatter
		http://blog.golang.org/go-fmt-your-code

# More parser tests:
http://lua-users.org/wiki/LuaGrammar

# Lua Links
# ---------

# lua formatters/ast emitters
http://metalua.luaforge.net/
http://lua-users.org/wiki/LuaInspect
https://github.com/batrick/lunadry # most recent
http://codepad.org/vRQx1O8A # block/non-block keywords
http://lua-users.org/wiki/SourceCodeFormatter
https://github.com/LuaDist/luapretty/blob/master/src/lua-formatter.lua
http://notebook.kulchenko.com/programming/lua-beautifier-in-55-lines-of-perl

# style guides
http://lua-users.org/wiki/LuaStyleGuide
http://sputnik.freewisdom.org/en/Coding_Standard

# testing framework
http://olivinelabs.com/busted/
# code optimizer
http://lua-users.org/wiki/SourceOptimizer

# Lua IDE
http://studio.zerobrane.com/

# AST-based formatter/linter
	subtle comma (Kolesnikov)

# Questions to be asked when enough tests will pass
# -------------------------------------------------

#
# How to/If we need to interpret these escape sequences (2.1 – Lexical Conventions) 
#
    <double quoted String char> ~ <C escape sequence>
    <double quoted String char> ~ <escape sequence of decimal digits>

    <single quoted String char> ~ <C escape sequence>
    <single quoted String char> ~ <escape sequence of decimal digits>

    <C escape sequence> ~ '\a' # bell
    <C escape sequence> ~ '\b' # backspace
    <C escape sequence> ~ '\f' # form feed
    <C escape sequence> ~ '\n' # newline
    <C escape sequence> ~ '\r' # carriage return
    <C escape sequence> ~ '\t' # horizontal tab
    <C escape sequence> ~ '\v' # vertical tab
    <C escape sequence> ~ '\\' # backslash
		\"	double quote #"
		\'	single quote #'
		\[	left square bracket
		\]	right square bracket
   
    
Links
-----

https://github.com/jddurand/MarpaX-Languages-C-AST/blob/master/lib/MarpaX/Languages/C/AST/Grammar/ISO_ANSI_C_2011.pm
https://github.com/jeffreykegler/Marpa--R2/blob/master/cpan/lib/Marpa/R2/meta/metag.bnf
