# eliminate <* comment> lexemes, use '--' <* string> instead
	
	
# cases for extensible parser -- smart preprocessing
# malleable syntax -- like the language but hate some of its syntax
	Hate ends? Use curlies!
		for ... end 				-> for ... { ... }
		do ... end 					-> do { ... }
		while ... end 			-> while { ... }
		repeat ... until 		-> repeat { ... } until
		function () ... end	-> sub (...){...}
	replace some grammar BNF rules with new ones
	
	# blocks
	# comments
	# strings
	# local to my

# extensible lexer (start here, backport to MarpaX::Languages::SLIF::AST)
	# move a SLIF grammar to general lexing
	given a SLIF grammar, 
		
		build an external lexer for it 
		
		sub read ( $recce, $input ){} for it with external lexing
		terminals, literals, L0 rules, unicorns, read
		custom lexemes, e.g. 
			String ::= <long nestable string> 
			<long nestable string> ~ ...
			exist in SLIF grammar, but do not really parse nested strings
			<long nestable string> => regex will ensure that it does

	given a SLIF grammar with events
		build sub read ( $recce, $input ){} to do event-handling heavy lifting
		calling callbacks as needed
	
# words * contexts = translations
	inflected form
	semantic form
	search/replace safety

# the Lua SLIF grammar is highly ambiguous, at times with over 100 ASTs
	get Marpa::R2::Glade generate PFG rules lazily for pruning

# todo: ast distill, capture group-based lexer, format

use PFG and the context will be right here

move fmt to handlers => {
	'stat/if' => sub {
	},
	
}

extensible lexer, extensible grammar, grammar algebra
parse to grammar (graph), not AST (tree)
	ambiguity is not a problem

MarpaX::Languages::SLIF::AST
	prepare for external lexing
	extensible lexer
		capture groups
	extensible grammar
		grammar algebra based on namespaces
			+ enable some syntax
			- disable some syntax
			* 
			/

MarpaX::AST
	traversal
		unwind left right recursion to sequences
		format as an 

MarpaX::ASF::PFG
	contexts

# motivation for formatter
	http://blog.golang.org/go-fmt-your-code

# extend
	general lexing
	extract terminals from extension grammar for lexemes

# ast distill
	flatten left recursion
		statements
		*list
	
# fmt
	context
		@start[$level]
		start block node_id of the same level
			function for while end
			if else elseif
			repeat until
  $s .= "\n" if node_id eq stat and level == 0
		
		
# ast traversal

# highlights
	extensible parser
	traversable Lua AST

# check for ambiguity

# find a job for lua parser
	help port lua 5.1 code to lua 5.2 -- What Lua 5.1 code breaks in Lua 5.2
	http://www.luafaq.org/#T8.1

# More parser tests:
http://lua-users.org/wiki/LuaGrammar

# Lua Links
# ---------

# lua formatters/ast emitters
http://metalua.luaforge.net/
http://lua-users.org/wiki/LuaInspect
https://github.com/batrick/lunadry # most recent
http://codepad.org/vRQx1O8A # block/non-block keywords
http://lua-users.org/wiki/SourceCodeFormatter
https://github.com/LuaDist/luapretty/blob/master/src/lua-formatter.lua
http://notebook.kulchenko.com/programming/lua-beautifier-in-55-lines-of-perl

# style guides
http://lua-users.org/wiki/LuaStyleGuide
http://sputnik.freewisdom.org/en/Coding_Standard

# testing framework
http://olivinelabs.com/busted/
# code optimizer
http://lua-users.org/wiki/SourceOptimizer

# Lua IDE
http://studio.zerobrane.com/

# AST-based formatter/linter
	subtle comma (Kolesnikov)

# Questions to be asked when enough tests will pass
# -------------------------------------------------

#
# How to/If we need to interpret these escape sequences (2.1 – Lexical Conventions) 
#
    <double quoted String char> ~ <C escape sequence>
    <double quoted String char> ~ <escape sequence of decimal digits>

    <single quoted String char> ~ <C escape sequence>
    <single quoted String char> ~ <escape sequence of decimal digits>

    <C escape sequence> ~ '\a' # bell
    <C escape sequence> ~ '\b' # backspace
    <C escape sequence> ~ '\f' # form feed
    <C escape sequence> ~ '\n' # newline
    <C escape sequence> ~ '\r' # carriage return
    <C escape sequence> ~ '\t' # horizontal tab
    <C escape sequence> ~ '\v' # vertical tab
    <C escape sequence> ~ '\\' # backslash
		\"	double quote #"
		\'	single quote #'
		\[	left square bracket
		\]	right square bracket
   
    
Links
-----

https://github.com/jddurand/MarpaX-Languages-C-AST/blob/master/lib/MarpaX/Languages/C/AST/Grammar/ISO_ANSI_C_2011.pm
https://github.com/jeffreykegler/Marpa--R2/blob/master/cpan/lib/Marpa/R2/meta/metag.bnf
